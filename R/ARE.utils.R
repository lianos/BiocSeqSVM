## This code is taken from my github.com/lianos/ARE.utils package

trim.data <- function(x, qtile=0.01, trim.to=c("NA", "quantile", "remove"),
                      side=c('both', 'upper', 'lower')) {
  trim.to <- match.arg(trim.to)
  side <- match.arg(side)
  if (side == 'both') {
    side <- c('upper', 'lower')
  }

  qtile <- min(qtile, 1-qtile, na.rm=TRUE)
  lo <- quantile(x, qtile, na.rm=TRUE)
  hi <- quantile(x, 1-qtile, na.rm=TRUE)

  if ('lower' %in% side) {
    x[x < lo] <- if (trim.to == "quantile") lo else NA
  }
  if ('upper' %in% side) {
    x[x > hi] <- if (trim.to == "quantile") hi else NA
  }

  if (trim.to == "remove") {
    x <- x[!is.na(x)]
  }

  x
}

match.dim <- function(margin) {
  # You can specify the margin by the index used to reference it, or by
  # it's name. This function returns which dimension to "run-over":
  #   - 1 is rows
  #   - 2 is cols
  # (This function is vectorized, tho I'm not sure why)
  rows <- which(margin %in% c('r', 'row', 'rows', 1))
  cols <- which(margin %in% c('c', 'col', 'cols', 'column', 'columns', 2))
  result <- numeric(length(margin))
  result[rows] <- 1
  result[cols] <- 2
  result[-c(rows,cols)] <- NA
  result
}

create.densities <- function(..., along=1, density.params=list(), na.rm=TRUE) {
  along <- match.dim(along)
  stopifnot(along %in% c(1,2))
  if (is.null(density.params$na.rm)) {
    density.params$na.rm <- na.rm
  }

  data <- list(...)
  if (length(data) == 1) {
    data <- data[[1]]
  }
  if (is.data.frame(data)) {
    data <- as.list(data)
  }
  if (is.list(data)) {
    data <- lapply(data, function(item) {
      if (is(item, 'density')) {
        ans <- item
      } else {
        if (length(item) < 2) {
          warning("Trying to create a density out of < 2 items")
          ans <- NULL
        } else {
          ans <- do.call(density, c(list(item), density.params))
        }
      }
      ans
    })
  } else if (is.matrix(data)) {
    n.samples <- dim(data)[along]
    if (along == 2) data <- t(data)
    data <- lapply(seq(n.samples), function (idx) {
      do.call(density, c(list(data[idx,]), density.params))
    })
  }
  data
}

plot.densities <- function(..., along=2, density.params=list(),
                           plot.params=list(), legend=NULL,
                           na.rm=TRUE, main="Densities") {
  # Plot the densities from many examples into one plot.
  # Returns the densities used as a list.
  #
  # WARNING: If you don't explicitly pass in the `along` function, but rather
  #          call `plot.densiteis(data, 'cols')`, this gets hosed
  #
  # ...            : The data to plot the densities for, this can be:
  #                :   - items, to, create, densities, from
  #                :   - a list of densities
  #                :   - a list of numbers
  #                :   - a Nx2 matrix of data, where each row/column is a
  #                :     separate set of observations. Specify which dimension
  #                :     to use by `along`
  # along          : The dimension that holds the data for 1 example.
  #                : 1 is rows, 2 is columns
  # density.params : list of parameters to pass to the `density` function, if we
  #                : have to create densites on the fly. Popular values would be:
  #                :   density.params=list(n=512, kernel='gaussian', na.rm=TRUE)
  #                : Note that passing nothing here will simply use the default
  #                : args
  # plot.params    : like density.params, but for the plot function, you might do
  #                :   plot.params=list(col=rainbow(20), main='Some Title')
  #                : If no `col` is passed, it is autogenerated
  data <- list(...)
  if (all(sapply(data, is, 'density'))) {
    data <- data
  } else if (is.list(data[[1]]) && all(sapply(data[[1]], is, 'density'))) {
    data <- data[[1]]
  } else {
    along <- match.dim(along)
    data <- create.densities(..., along=along, na.rm=na.rm,
                             density.params=density.params)
  }
  stopifnot(is.list(data))
  keep <- sapply(data, is, 'density')
  if (!any(keep)) {
    stop("All items passed in created empty densities")
  }

  data <- data[keep]

  if (is.character(legend) && length(legend) != length(keep)) {
    warning("Number of items in legend is different than number of data points")
    legend <- NULL
  } else {
    legend <- legend[keep]
  }

  col <- rainbow(sum(keep))
  if (is.character(plot.params$col)) {
    if (length(col) != length(keep)) {
      warning("Colors do not match data length, using rainbow")
    } else {
      col <- plot.params$col[keep]
    }
  }
  plot.params$col <- col

  if (is.null(plot.params$ylim)) {
    y.max <- max(unlist(lapply(data, function (d) max(d$y))))
    plot.params$ylim <- c(0, y.max)
  }
  if (is.null(plot.params$xlim)) {
    x.min <- min(unlist(lapply(data, function (d) min(d$x))))
    x.max <- max(unlist(lapply(data, function (d) max(d$x))))
    plot.params$xlim <- c(x.min, x.max)
  }
  if (is.null(plot.params$main)) {
    plot.params$main <- main
  }
  if (is.null(plot.params$ylab)) {
    plot.params$ylab <- "Density"
  }
  if (is.null(plot.params$lwd)) {
    plot.params$lwd <- 1.5
  }

  do.call(plot, c(list(data[[1]]), plot.params))
  if (length(data) > 1) {
    for (idx in 2:length(data)) {
      rm.params <- c('main', 'xlab', 'ylab')
      line.params <- plot.params[!names(plot.params) %in% rm.params]
      line.params$col <- plot.params$col[idx]
      do.call(lines, c(list(data[[idx]]), line.params))
    }
  }

  if (is.character(legend)) {
    legend('topright', legend=legend, text.col=col)
  }

  invisible(data)
}
